«адание є1
 акой тип будет у данного выражени€:
typeof 1  // number

typeof У1Ф  //string  (подразумевались стандартные двойные кавычки ""?)

typeof NaN  //number (специальное числовое значение нар€ду с Infinity)

typeof true  //boolean

typeof {}  //object ({} - пустой объект)

typeof 1 && 3  //number (сначала выполнитс€ typeof 1 с результатом "number" - строка. “.к. и строка и число в логическом выражении равносильны true,
то все выражение typeof 1 && 3 вернет в качестве результата последнее неложное значение - число 3, которое имеет тип number)

typeof (1 && 3)  //number (“.к. числа в логическом выражении равносильны true,
то выражение 1 && 3 вернет в качестве результата последнее неложное значение - 3, которое имеет тип number)

typeof undefined  //undefined

typeof null  //object ("официально признанна€ ошибка в €зыке, котора€ сохран€етс€ дл€ совместимости")

typeof 5 || 5  //string (сначала выполнитс€ typeof 5 с результатом "number" - строка. “.к. в логическом выражении строка равносильна true, 
то по короткому циклу вычислений все выражение typeof 5 || 5 возвратит строку "number" с типом string)



«адание є2
ѕримеры (определи, что получитс€):
"1234".substring(0, 2) // '12' (символы с 0 до 1 включительно)
"1234".substr(0, 2) // '12' (2 символа, начина€ с 0)



«адание є3
¬ерно ли утверждение:
"1234".substr(2, 3) === "1234".substring(2, 3) // '34'==='3' - false (не совпадают сами строки)
"1234".substring(0, 2) === "1234".slice(0, 2) // '12'==='12' - true 
"1234".substr(0, 2) === "1234".indexOf(0, 2) // '12'=== -1 - false - не совпадают типы и сами значени€ (indexOf(0, 2) - поиск 0 со 2й позиции. ≈сли значение не найдено, то по умолчанию возвращаетс€ -1)


